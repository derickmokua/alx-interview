# README for "0. Change Comes from Within" Project

## Project Overview

For the **"0. Change Comes from Within"** project, I tackled the classic **Coin Change Problem** using both **greedy algorithms** and **dynamic programming**. The goal was to find the minimum number of coins needed to make up a given total amount, given a list of coin denominations. Throughout the project, I applied algorithmic concepts to devise solutions that were not only correct but also efficient.

## Key Concepts I Worked With

### 1. **Greedy Algorithms**
   - I explored how **greedy algorithms** work and why they can be effective for the coin change problem in certain cases.
   - I also recognized the limitations of greedy approaches, especially when they don’t guarantee an optimal solution for all sets of coin denominations.

### 2. **Dynamic Programming**
   - I applied **dynamic programming** to solve the problem in a more optimal way. I focused on understanding how to break the problem down into overlapping subproblems and how to use **optimal substructure** to build up the solution efficiently.

### 3. **Algorithmic Complexity**
   - I carefully analyzed the **time and space complexity** of both my greedy and dynamic programming solutions.
   - I made sure my solutions minimized complexity, ensuring they could handle larger inputs within reasonable runtime constraints.

### 4. **Problem-Solving Strategies**
   - I broke down the problem into smaller, more manageable subproblems to keep the solution clear and efficient.
   - I experimented with both **iterative** and **recursive** dynamic programming approaches, testing each for performance and clarity.

### 5. **Python Programming**
   - I used Python's list manipulation features and **list comprehensions** to implement the algorithms in a clean and efficient way.
   - I also leveraged Python’s control flow tools (loops, conditionals) to handle different cases and edge conditions effectively.

## Resources I Used

### 1. **Python Official Documentation**
   - I referred to the official Python documentation to review control flow tools (such as `for` loops and `if` statements) and make sure my code structure was optimal.

### 2. **GeeksforGeeks**
   - I studied articles on **Coin Change | DP-7** and the **Greedy Algorithm for Minimum Number of Coins** to deepen my understanding of the theory behind the problem and the approaches I was implementing.

### 3. **YouTube Tutorials**
   - I watched several tutorials on **Dynamic Programming - Coin Change Problem** to see step-by-step implementations of dynamic programming, which helped clarify certain concepts.

## My Approach

I started by implementing a **greedy algorithm** to solve the problem, which worked well for certain denominations but failed in others. After recognizing its limitations, I switched to a more robust **dynamic programming** solution, which provided the correct and optimal result for all test cases.

I focused on breaking down the problem into overlapping subproblems and used memoization to store intermediate results and avoid redundant computations. By analyzing both approaches, I was able to compare their performance and understand the trade-offs between simplicity and efficiency.

## Conclusion

Through this project, I gained a deeper understanding of both **greedy algorithms** and **dynamic programming**. I learned how to choose the right approach depending on the problem constraints and how to implement solutions that are not only correct but also efficient. This experience reinforced the importance of problem analysis and algorithmic thinking when developing solutions in Python.
